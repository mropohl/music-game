import { AUDIO_PARAM_AUDIO_NODE_STORE, AUDIO_PARAM_STORE } from '../globals';
import { getAudioGraph } from '../helpers/get-audio-graph';
const addAudioParam = (context, audioParam, audioParamRenderer) => {
    const audioGraph = getAudioGraph(context);
    audioGraph.params.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });
};
export const createAudioParamFactory = (createAudioParamRenderer, nativeAudioContextConstructor) => {
    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer() : null;
        const audioParam = {
            get defaultValue() {
                return nativeAudioParam.defaultValue;
            },
            get maxValue() {
                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;
            },
            get minValue() {
                return (minValue === null) ? nativeAudioParam.minValue : minValue;
            },
            get value() {
                return nativeAudioParam.value;
            },
            set value(value) {
                nativeAudioParam.value = value;
                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().
                audioParam.setValueAtTime(value, audioNode.context.currentTime);
            },
            cancelScheduledValues(cancelTime) {
                nativeAudioParam.cancelScheduledValues(cancelTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ cancelTime, type: 'cancelScheduledValues' });
                }
                return audioParam;
            },
            exponentialRampToValueAtTime(value, endTime) {
                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ endTime, type: 'exponentialRampToValue', value });
                }
                return audioParam;
            },
            linearRampToValueAtTime(value, endTime) {
                nativeAudioParam.linearRampToValueAtTime(value, endTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ endTime, type: 'linearRampToValue', value });
                }
                return audioParam;
            },
            setTargetAtTime(target, startTime, timeConstant) {
                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ startTime, target, timeConstant, type: 'setTarget' });
                }
                return audioParam;
            },
            setValueAtTime(value, startTime) {
                nativeAudioParam.setValueAtTime(value, startTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ startTime, type: 'setValue', value });
                }
                return audioParam;
            },
            setValueCurveAtTime(values, startTime, duration) {
                const type = 'setValueCurve';
                /*
                 * Bug #152: Safari does not correctly interpolate the values of the curve.
                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the
                 * existence of the webkitAudioContext is used as a workaround here.
                 */
                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {
                    const endTime = startTime + duration;
                    const sampleRate = audioNode.context.sampleRate;
                    const firstSample = Math.ceil(startTime * sampleRate);
                    const lastSample = Math.floor((endTime) * sampleRate);
                    const numberOfInterpolatedValues = lastSample - firstSample;
                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {
                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);
                        const lowerIndex = Math.floor(theoreticIndex);
                        const upperIndex = Math.ceil(theoreticIndex);
                        interpolatedValues[i] = (lowerIndex === upperIndex)
                            ? values[lowerIndex]
                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])
                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);
                    }
                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);
                    if (audioParamRenderer !== null) {
                        audioParamRenderer.record({ duration, startTime, type, values: interpolatedValues });
                    }
                    const timeOfLastSample = lastSample / sampleRate;
                    if (timeOfLastSample < endTime) {
                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
                    }
                    audioParam.setValueAtTime(values[values.length - 1], endTime);
                }
                else {
                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);
                    if (audioParamRenderer !== null) {
                        audioParamRenderer.record({ duration, startTime, type, values });
                    }
                }
                return audioParam;
            }
        };
        AUDIO_PARAM_STORE.set(audioParam, nativeAudioParam);
        AUDIO_PARAM_AUDIO_NODE_STORE.set(audioParam, audioNode);
        addAudioParam(audioNode.context, audioParam, audioParamRenderer);
        return audioParam;
    };
};
//# sourceMappingURL=/build/es2018/factories/audio-param-factory.js.map